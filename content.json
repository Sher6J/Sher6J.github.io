{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Sher6J","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"Java--基础笔记","slug":"Java-基础笔记","date":"2020-03-19T09:53:39.000Z","updated":"2020-03-19T12:38:21.552Z","comments":true,"path":"2020/03/19/Java-基础笔记/","link":"","permalink":"http://yoursite.com/2020/03/19/Java-%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/","excerpt":"","text":"##Java基础类型1.整数类型： byte：1 short：2 int(默认)：4 long:8 2.浮点类型： float：4 double(默认):8 3.字符类型： char:2 4.布尔类型 boolean:1##类型转换1.自动类型转换：把一个表示数据范围小的数值或者变量赋值给另一个表示数据范围大的变量。这种转换方式是自动的,直接书写即可。 2.强制类型转换：把一个表示数据范围大的数值或者变量赋值给另一个表示数据范围小的变量。 强制类型转换格式:目标数据类型 变量名 = (目标数据类型)值或者变量; 如：12double num1 = 5.5;int num2 = (int) num1; // 将double类型的num1强制转换为int类型 3.转换的数据类型，数据范围从小到大： byte -&gt; short -&gt; int -&gt; long -&gt; float -&gt; double char -&gt; int -&gt; long -&gt; float -&gt; double##运算符####只记录需要注意的运算符， +-等基本运算符不计入笔记1.逻辑运算符 &amp;(逻辑与)：a&amp;b,a和b都是true,结果为true,否则为false |(逻辑或)：a|b,a和b都是false,结果为false,否则为true ^(逻辑异或)：a^b,a和b结果不同为true,相同为false !(逻辑非)：!a,结果和a的结果正好相反 2.短路逻辑运算符 &amp;&amp;(短路与)：作用和&amp;相同,但是有短路效果 ||(短路或)：作用和|相同,但是有短路效果 3.什么是短路？ 逻辑与&amp;,无论左边真假,右边都要执行；短路与&amp;&amp;,如果左边为真,右边执行;如果左边为假,右边不执行。 逻辑或|,无论左边真假,右边都要执行；短路或||,如果左边为假,右边执行;如果左边为真,右边不执行。 4.三元运算符 关系表达式 ? 表达式1 : 表达式2;1int c = a &gt; b ? a : b; // 判断 a&gt;b 是否为真,如果为真取a的值,如果为假,取b的值 ##流程控制语句1.顺序结构 2.分支结构：if, switch. if没什么可说的，switch做点笔记 switch具有穿透功能，何谓穿透，如下面代码：1234567switch(month) &#123; case 1: case 2: case 12: System.out.println(\"冬季\"); break;&#125; 当判断month==1时，由于case 1中没有break，所以程序会一直向下执行到知道有break的case语句，所以month==1时，程序会输出“冬季”。 现在的switch语句中参数支持字符串 3.循环结构：for, while, do……while. 也没什么可多说的，增强for以后再说，此处写点小笔记 死循环(无限循环)的三种格式 for(;;){} while(true){} do {} while(true);##数组1.数组初始化 动态初始化：数据类型 [] 数组名 = new 数据类型[数组长度];1int[] arr = new int[3]; 静态初始化：数据类型 [] 数组名 = new 数据类型[]{元素1,元素2,…}; 静态初始化简化格式：数据类型 [] 数组名 = {元素1,元素2,…}; 2.Java中的内存分配：目前只需要记住两个内存,分别是:栈内存和堆内存 寄存器 给CPU使用,和我们开发无关。 本地方法栈 JVM在使用操作系统功能的时候使用,和我们开发无关。 方法区 存储可以运行的class文件。 堆内存 存储对象或者数组,new来创建的,都存储在堆内存。 方法栈 方法运行时使用的内存,比如main方法运行,进入方法栈中执行。##方法method####方法的 重载Overload和重写Override####完全不同的两个概念1.重载Overload 方法重载指同一个类中定义的多个方法之间的关系,满足下列条件的多个方法相互构成重载 多个方法在同一个类中 多个方法具有相同的方法名 多个方法的参数不相同,类型不同或者数量不同 注意： 重载仅对应方法的定义,与方法的调用无关,调用方式参照标准格式 重载仅针对同一个类中方法的名称与参数进行识别,与返回值无关,换句话说不能通过返回值来判定两个方法是否相互构成重载 重载规则: 被重载的方法必须改变参数列表(参数个数或类型不一样)； 被重载的方法可以改变返回类型； 被重载的方法可以改变访问修饰符； 被重载的方法可以声明新的或更广的检查异常； 方法能够在同一个类中或者在一个子类中被重载; 无法以返回值类型作为重载函数的区分标准。 2.重写Override 方法重写概念：子类出现了和父类中一模一样的方法声明(方法名一样,参数列表也必须一样) 方法重写的应用场景：当子类需要父类的功能,而功能主体子类有自己特有内容时,可以重写父类中的方法,这样,即沿袭了父类的功能,又定义了子类特有的内容 方法重写的注意事项 私有方法不能被重写(父类私有成员子类是不能继承的) 子类方法访问权限不能更低(public &gt; 默认 &gt; 私有) 方法的重写规则 参数列表必须完全与被重写方法的相同。 返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。 父类的成员方法只能被它的子类重写。 声明为 final 的方法不能被重写。 声明为 static 的方法不能被重写，但是能够被再次声明。 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。 子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。 构造方法不能被重写。 如果不能继承一个方法，则不能重写这个方法。 3.重写与重载区别： 方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。 方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。 方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。 方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。##类和对象类的定义和对象的创建与室友不做赘述 1.类和对象的关系 类:类是对现实生活中一类具有共同属性和行为的事物的抽象 对象:是能够看得到摸的着的真实存在的实体 简单理解: 类是对事物的一种描述,对象则为具体存在的事物 2.this关键字 this修饰的变量用于指代成员变量,其主要作用是(区分局部变量和成员变量的重名问题) 方法的形参如果与成员变量同名,不带this修饰的变量指的是形参,而不是成员变量 方法的形参没有与成员变量同名,不带this修饰的变量指的是成员变量 简单理解,this代表当前调用方法的引用,哪个对象调用的方法,this就代表哪一个对象 3.super关键字 涉及类的继承 this&amp;super 关键字: this :代表本类对象的引用 super :代表父类存储空间的标识(可以理解为父类对象引用) this和super的使用分别 成员变量: this. 成员变量 - 访问本类成员变量 super. 成员变量 - 访问父类成员变量 成员方法: this. 成员方法 - 访问本类成员方法 super. 成员方法 - 访问父类成员方法 构造方法: this(…) - 访问本类构造方法 super(…) - 访问父类构造方法 4.构造方法： 格式:public class 类名{修饰符 类名( 参数 ) {}} 功能:主要是完成对象数据的初始化 注意： 构造方法的创建：如果没有定义构造方法,系统将给出一个默认的无参数构造方法；如果定义了构造方法,系统将不再提供默认的构造方法 构造方法的重载：如果自定义了带参构造方法,还要使用无参数构造方法,就必须再写一个无参数构造方法 推荐的使用方式无论是否使用,都手工书写无参数构造方法 IntelliJ Idea开发工具中可以用 alt + insert 快捷键自动生成如构造方法,get/set方法,重写等方法等 5.权限修饰符–可访问，级别由高到低 private：同一个类中 默认：同一个类中；同一个包中子类、无关类 protected：同一个类中；同一个包中子类、无关类；不同包中子类 public：同一个类中；同一个包中子类、无关类；不同包中子类；不同包中无关类 6.final关键字 final 代表最终的意思,可以修饰成员方法,成员变量,类,意思就是不能再改变 final 修饰类:该类不能被继承(不能有子类,但是可以有父类) final 修饰方法:该方法不能被重写 final 修饰变量:表明该变量是一个常量,不能再次赋值 7.static关键字 static的概念：static 关键字是静态的意思,可以修饰成员方法,成员变量 static修饰的特点 被类的所有对象共享,这也是我们判断是否使用静态关键字的条件 可以通过类名调用当然,也可以通过对象名调用,推荐使用类名调用 static的访问特点 非静态的成员方法 能访问静态的成员变量 能访问非静态的成员变量 能访问静态的成员方法 能访问非静态的成员方法 静态的成员方法 能访问静态的成员变量 能访问静态的成员方法 即－－静态成员方法只能访问静态成员 8.类、抽象类、接口关系梳理，具体概念语法等不做赘述 类和接口 类与类的关系 继承关系,只能单继承,但是可以多层继承 类与接口的关系 实现关系,可以单实现,也可以多实现,还可以在继承一个类的同时实现多个接口 接口与接口的关系 继承关系,可以单继承,也可以多继承 抽象类和接口 成员区别 抽象类：变量,常量;有构造方法;有抽象方法,也有非抽象方法 接口：常量;抽象方法 关系区别 类与类：继承,单继承 类与接口：实现,可以单实现,也可以多实现 接口与接口：继承,单继承,多继承 设计理念区别 抽象类：对类抽象,包括属性、行为 接口：对行为抽象,主要是行为##Java的三大特性 1.封装 封装是面向对象编程语言对客观世界的模拟,客观世界里成员变量都是隐藏在对象内部的,外界是无法直接操作的 封装原则：将类的某些信息隐藏在类内部,不允许外部程序直接访问,而是通过该类提供的方法来实现对隐藏信息的操作和访问成员变量private,提供对应的getXxx()/setXxx()方法 封装好处：通过方法来控制成员变量的操作,提高了代码的安全性 把代码用方法进行封装,提高了代码的复用性 2.继承 继承的概念：继承是面向对象三大特征之一,可以使得子类具有父类的属性和方法,还可以在子类中重新定义,以及追加属性和方法 实现继承的格式：继承通过 extends实现 格式: class 子类 extends 父类 { } 举例: class Dog extends Animal { } 继承带来的好处：继承可以让类与类之间产生关系,子父类关系,产生子父类后,子类则可以使用父类中非私有的成员 继承的好处和弊端(理解) 继承好处 提高了代码的复用性 (多个类相同的成员可以放到同一个类中) 提高了代码的维护性 (如果方法的代码需要修改,修改一处即可) 继承弊端 继承让类与类之间产生了关系,类的耦合性增强了,当父类发生变化时子类实现也不得不跟着变化,削弱了子类的独立性 继承的应用场景:使用继承,需要考虑类与类之间是否存在 is..a的关系,不能盲目使用继承 is..a 的关系:谁是谁的一种,例如:老师和学生是人的一种,那人就是父类,学生和老师就是子类 继承中的访问特点 继承中变量的访问特点：在子类方法中访问一个变量,采用的是就近原则。 子类局部范围找 子类成员范围找 父类成员范围找 如果都没有就报错(不考虑父亲的父亲…) 继承中构造方法的访问特点 子类中所有的构造方法默认都会访问父类中无参的构造方法 子类会继承父类中的数据,可能还会使用父类的数据。 所以,子类初始化之前,一定要先完成父类数据的初始化,原因在于,每一个子类构造方法的第一条语句默认都是:super() 问题:如果父类中没有无参构造方法,只有带参构造方法,该怎么办呢? 通过使用super关键字去显示的调用父类的带参构造方法 在父类中自己提供一个无参构造方法 推荐方案:自己给出无参构造方法 继承中成员方法的访问特点：通过子类对象访问一个方法 子类成员范围找 父类成员范围找 如果都没有就报错(不考虑父亲的父亲…) 3.多态 多态的概述 什么是多态：同一个对象,在不同时刻表现出来的不同形态 多态的前提 要有继承或实现关系 要有方法的重写 要有父类引用指向子类对象 多态中的成员访问特点 成员变量：编译看父类,运行看父类 成员方法：编译看父类,运行看子类 多态中的转型 向上转型：父类引用指向子类对象就是向上转型 向下转型：格式 子类型 对象名 = (子类型)父类引用;","categories":[],"tags":[]},{"title":"在Ubuntu中安装MySQL","slug":"在Ubuntu中安装MySQL","date":"2020-03-19T05:19:37.000Z","updated":"2020-03-19T05:47:17.296Z","comments":true,"path":"2020/03/19/在Ubuntu中安装MySQL/","link":"","permalink":"http://yoursite.com/2020/03/19/%E5%9C%A8Ubuntu%E4%B8%AD%E5%AE%89%E8%A3%85MySQL/","excerpt":"","text":"在终端中敲入如下命令1$ sudo apt-get install mysql-server 根据提示点Y即可 1$ sudo apt-get install mysql-client 接下来修改MySQL配置，用vim或是gedit均可，由于我比较懒，所以用gedit 1$ sudo gedit /etc/mysql/mysql.conf.d/mysqld.cnf 这样后就进入到MySQL配置文件：为了可以远程访问，注释掉 bind-address = 127.0.0.1 这行 在配置文件中的[mysqld]这一块中加入 skip-grant-tables，目的是为了跳过密码直接登录，因为我希望登录都输入秘密，所以我将这行注释到，同时为了防止中文乱码，要加入 character-set-server=utf8，配置后我的[mysqld]这一块如下： 比较重要的是port参数，众所周知MySQL的端口为3306，不建议修改。 输入 sudo service mysql start 启动MySQL 1$ sudo service mysql start 输入 mysql -uroot -p 后填入root密码即可进入数据库 1$ mysql -uroot -p 以上就是在Ubuntu中安装MySQL数据库的详细过程，最重要的是MySQL配置文件的配置，配置好MySQL服务后即可用其他图形化界面来操作数据库，推荐使用phpMyAdmin。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-03-18T14:11:50.714Z","updated":"2020-03-18T14:11:50.714Z","comments":true,"path":"2020/03/18/hello-world/","link":"","permalink":"http://yoursite.com/2020/03/18/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}